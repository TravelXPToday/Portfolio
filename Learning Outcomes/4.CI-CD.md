
<img src="https://cdn.dribbble.com/users/2978360/screenshots/6914572/comp_1.gif">

# CI-CD

 > You **implement** a (semi)automated software release process that matches the needs of the project context
 > 
 >**Implement** : 	You implement a continuous integration and deployment solution (using e.g. Gitlab CI and Docker).
>
>[^1]

Table of Contents
- [CI-CD](#ci-cd)
- [What is CI-CD](#what-is-ci-cd)
  - [Understanding CI](#understanding-ci)
  - [Continuous Delivery](#continuous-delivery)
- [Why](#why)
- [How do we implement CI-CD](#how-do-we-implement-ci-cd)
- [front-end](#front-end)
  - [CI pipeline:](#ci-pipeline)
  - [CD](#cd)
- [Back-end](#back-end)
  - [CI pipeline:](#ci-pipeline-1)
  - [CD](#cd-1)
    - [Examples](#examples)
- [Sources](#sources)

 # What is CI-CD

 CI/CD, short for Continuous Integration and Continuous Deployment, automates the building, testing, and deployment of code. This streamlines the workflow, enhances code quality, and accelerates the release of new features or fixes.

## Understanding CI

CI, an abbreviation for Continuous Integration, is a core component of the CI/CD paradigm in software development. It is an automated process where developers integrate their code changes into a shared repository frequently. Each integration is then automatically built and tested to ensure that new changes do not break the existing codebase. The objective is to identify and address conflicts early, fostering a more streamlined and efficient development process.

[^2]
## Continuous Delivery
This aspect of CI/CD focuses on the automated testing and sharing of code changes. After developers commit their changes, the code undergoes automated tests and is then added to a shared repository. Operations teams can subsequently deploy these changes to the production environment. This practice enhances collaboration between developers and business stakeholders and facilitates effortless deployment of new code iterations.

Continuous Deployment
This process extends beyond Continuous Delivery, automating not just the testing and sharing of code, but also its deployment to production. Every change that passes the automated tests is automatically deployed to the live environment, expediting the software delivery process and eliminating manual interventions.

[^2]

# Why
In addition to supporting these larger goals, CI/CD enables you to:

`Ship software quickly and efficiently`: CI/CD pipelines move applications from the coding to deployment phases at scale, ensuring that the pace of development matches the needs of the business.

`Increase productivity`: By implementing automated processes, development and operations teams are no longer spending time merging, building, testing, releasing, and deploying software manually. Instead, they can focus on writing better code and monitoring deployments for issues.

`Reduce risk on delivery:` Testing every change before it's deployed ensures that the result will be a higher quality product and lower the rate of bugs in production. Customers will receive a better product, and the development team will spend less time fixing urgent defects discovered after release.

`Incorporate user feedback faster`: CI/CD removes traditional roadblocks for development and operations teams, enabling the faster release of new features to meet users' needs. This will increase customer satisfaction and provide valuable insights into the capabilities that users value for future projects.

`Standardize processes`: Automating the merge, test, delivery, and deployment processes means that they will always follow the same structure. This standardizes the pipeline, whereas manual execution of these tasks always comes with the risk of human error, such as executing tests in a different order.
[^3]


# How do we implement CI-CD
We implement CI-CD by using the following technologies:
- [Gitlab CI](https://docs.gitlab.com/ee/ci/)
- [Docker](https://www.docker.com/)
- [Vercel](https://vercel.com/)

# front-end 
## CI pipeline:
```yaml	
name: Python application

on:
  push:
    branches:
      - main
      - DEV
  pull_request:
    branches: 
      - main
      - DEV
permissions:
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up Python 3.10
      uses: actions/setup-python@v3
      with:
        python-version: "3.10"

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flake8 pytest
        pip install -r API/requirements.txt
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
    - name: Set PYTHONPATH
      run: echo "PYTHONPATH=$PWD" >> $GITHUB_ENV

    - name: Test with pytest
      run: |
        pytest API/tests/
```
It triggers on push or pull request events to the main or DEV branches. The workflow runs on the latest Ubuntu, checks out the code, sets up Python 3.10, installs dependencies, sets the PYTHONPATH, and runs pytest for testing.
## CD
we plan on using Docker
```yaml

```
# Back-end
## CI pipeline:
```yaml
```
## CD 
We deploy our back-end on Vercel. This automatically deploys our front-end when we push to the main branch. that is why we want to make sure that before it gets deployed, it passes all the tests.
here are some images as an example of how we deploy our front-end on Vercel.

### Examples

<img src="https://github.com/TravelXPToday/Portfolio/blob/main/Images/MicrosoftTeams-image%20(2).png?raw=true" />


---

<img src="https://github.com/TravelXPToday/Portfolio/blob/main/Images/MicrosoftTeams-image%20(1).png?raw=true" />

We use Vercel to deploy our Create React App because it offers a seamless deployment experience tailored for modern web projects like ours. With Vercel, we can easily push our code to a repository, and it automatically builds and deploys the application in an optimized manner. It provides a live URL for each deployment and every pull request, making it effortless for us to share and preview our work in real-time.

Vercel's built-in CDN ensures our app is delivered quickly to users around the world, and the platform’s scalability means we don’t have to worry about infrastructure as our user base grows. We can focus on building great features, while Vercel takes care of the deployment and hosting intricacies. This streamlined workflow enhances our productivity, allowing us to deliver high-quality applications at a faster pace
 # Sources
[^1]: Canvas. (n.d.). Canvas outcomes. Retrieved September 21, 2023, from https://fhict.instructure.com/courses/13181/outcomes

[^2]: Red Hat. (2022, May 11). What is CI/CD? Retrieved october 5, 2023, from https://www.redhat.com/en/topics/devops/what-is-ci-cd?pfe-x1m7zato6=products

[^3]: Stephen Roddewig. (2022, February 8). CI/CD: What Is It & Why Is It Important for DevOps? Retrieved october 5, 2023, from https://blog.hubspot.com/website/cicd ↩

